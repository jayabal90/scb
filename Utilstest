import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import { exceptionCheck } from './path/to/your/exceptionCheck';
import { errorAction } from "../utils/store/error-slice"; // Adjust the path as needed
import { dispatchLoader } from "./common-service"; // Adjust the path as needed

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe("exceptionCheck", () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({});
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should resolve for CONTINUE action with INFO response type", async () => {
    const response = {
      status: 200,
      data: {
        application: {
          response_action: "CONTINUE",
          response_type: "INFO"
        }
      }
    };
    
    await store.dispatch(exceptionCheck(response));
    expect(store.getActions()).toEqual([]);
  });

  it("should dispatch error for RESUBMIT action with errors", async () => {
    const response = {
      status: 200,
      data: {
        application: {
          response_action: "RESUBMIT",
          response_type: "HARD",
          errors: {
            errors: [{ detail: "Some error occurred." }]
          }
        }
      }
    };

    await store.dispatch(exceptionCheck(response)).catch((err) => {
      expect(err).toBe("Rejected");
      const actions = store.getActions();
      expect(actions).toContainEqual(errorAction.getRetryStatus(true));
      expect(actions).toContainEqual(expect.objectContaining(dispatchLoader(false)));
    });
  });

  it("should resolve for SUCCESS action with SOFT response type", async () => {
    const response = {
      status: 200,
      data: {
        application: {
          response_action: "SUCCESS",
          response_type: "SOFT"
        }
      }
    };

    await store.dispatch(exceptionCheck(response));
    expect(store.getActions()).toEqual([]);
  });

  it("should dispatch error for STOP action with HARD response type", async () => {
    const response = {
      status: 200,
      data: {
        application: {
          response_action: "STOP",
          response_type: "HARD",
          errors: {
            errors: [{ detail: "Some error occurred." }]
          }
        }
      }
    };

    await store.dispatch(exceptionCheck(response)).catch((err) => {
      expect(err).toBe("Rejected");
      const actions = store.getActions();
      expect(actions).toContainEqual(expect.objectContaining(errorAction.getExceptionList(expect.anything())));
      expect(actions).toContainEqual(dispatchLoader(false));
    });
  });

  it("should reject for non 200 or 201 status", async () => {
    const response = {
      status: 400,
      data: {}
    };

    await store.dispatch(exceptionCheck(response)).catch((err) => {
      expect(err).toBe("Rejected");
      const actions = store.getActions();
      expect(actions).toContainEqual(expect.objectContaining(errorAction.getExceptionList(expect.anything())));
    });
  });
});
