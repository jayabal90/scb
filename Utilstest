import { getFields } from './path/to/getFields';
import { fieldErrorAction } from '../../../utils/store/field-error-slice';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import { act } from 'react-dom/test-utils';

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

describe('getFields action creator', () => {
    let store;

    beforeEach(() => {
        store = mockStore({});
    });

    it('should return null when no getStages are provided', () => {
        const radioResidency = null;

        act(() => {
            store.dispatch(getFields([], radioResidency));
        });

        const actions = store.getActions();
        expect(actions).toEqual([]);
    });

    it('should dispatch fieldErrorAction when radioResidency is set and a valid field is present', () => {
        const radioResidency = {
            logical_field_name: 'marketing_phone_all',
            value: 'N'
        };

        const getStages = [
            {
                stageId: 'stage1',
                stageInfo: {
                    fieldMetaData: {
                        data: {
                            stages: [
                                {
                                    fields: [
                                        { logical_field_name: "marketing_phone_rm" },
                                        { logical_field_name: "other_field" },
                                    ]
                                }
                            ]
                        }
                    }
                }
            }
        ];

        act(() => {
            store.dispatch(getFields(getStages, radioResidency));
        });

        const actions = store.getActions();
        expect(actions).toContainEqual(fieldErrorAction.getMandatoryFields(["marketing_phone_rm"]));
    });

    it('should not dispatch fieldErrorAction if no fields match', () => {
        const radioResidency = {
            logical_field_name: 'marketing_phone_all',
            value: 'Y'
        };

        const getStages = [
            {
                stageId: 'stage1',
                stageInfo: {
                    fieldMetaData: {
                        data: {
                            stages: [
                                {
                                    fields: [
                                        { logical_field_name: "some_other_field" }
                                    ]
                                }
                            ]
                        }
                    }
                }
            }
        ];

        act(() => {
            store.dispatch(getFields(getStages, radioResidency));
        });

        const actions = store.getActions();
        expect(actions).not.toContainEqual(fieldErrorAction.getMandatoryFields(expect.anything()));
    });

    it('should return stage components when both ssfStages and fields are available', () => {
        const radioResidency = {
            logical_field_name: 'marketing_phone_all',
            value: 'N'
        };

        const getStages = [
            {
                stageId: 'stage1',
                stageInfo: {
                    fieldMetaData: {
                        data: {
                            stages: [
                                {
                                    fields: [
                                        { logical_field_name: "marketing_phone_rm" },
                                        { logical_field_name: "another_field" },
                                    ]
                                }
                            ]
                        }
                    }
                }
            }
        ];

        const returnValue = getFields(getStages, radioResidency)(store.dispatch);

        expect(returnValue).toEqual([
            { logical_field_name: "marketing_phone_rm" }
        ]);
    });
});
