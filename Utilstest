import { render } from '@testing-library/react';
import service from './path/to/your/service'; // Update the import to the actual path
import { store } from "../utils/store/store"; // ensure store is accessible for tests
import { getUrl } from "../utils/common/change.utils"; // ensure getUrl is accessible for tests

jest.mock("../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));

jest.mock("../utils/common/change.utils", () => ({
  getUrl: {
    getChannelRefNo: jest.fn().mockReturnValue({
      channelRefNo: '12345',
      applicationRefNo: 'app_001'
    }),
    getParameterByName: jest.fn().mockReturnValue('en'),
  }
}));

describe("Service Class", () => {
  let trackEvents;
  beforeEach(() => {
    trackEvents = new service();
    // Reset the store state before each test
    store.getState.mockClear();
  });

  test("getFormFieldValue returns correct value from LOv", () => {
    const stageMock = {
      stages: {
        userInput: {
          applicants: {
            'FieldName_a_1': 'code1',
          },
        },
        stages: [{
          stageInfo: {
            applicants: {
              'FieldName_a_1': null,
            },
          },
        }],
      },
      lov: { 
        lov: [
          {
            label: 'FieldName',
            value: [{ CODE_VALUE: 'code1', CODE_DESC: 'Value Desc' }]
          },
        ],
      },
    };

    const result = trackEvents.getFormFieldValue('FieldName', stageMock, 'Yes');
    expect(result).toBe('Value Desc');
  });

  test("getFormFieldValue returns 'na' for non-existent field", () => {
    const stageMock = {
      stages: {
        userInput: {
          applicants: {},
        },
        stages: [{
          stageInfo: {
            applicants: {},
          }
        }],
      },
      lov: {},
    };

    const result = trackEvents.getFormFieldValue('NonExistentField', stageMock, 'Yes');
    expect(result).toBe('na');
  });

  test("getFormFields returns fields", () => {
    const stageMock = {
      stages: {
        stages: [{
          stageInfo: {
            fieldMetaData: {
              data: {
                stages: [{
                  stageId: 'someStageId',
                  fields: [{ 
                    logical_field_name: 'FieldName', 
                    rwb_label_name: 'Tenor & monthly repayment', 
                    lov: 'Yes' 
                  }],
                }],
              },
            },
          },
        }],
      },
    };

    const result = trackEvents.getFormFields('someStageId', stageMock, ['FieldName']);
    expect(result).toEqual(expect.arrayContaining([expect.objectContaining({
      formFieldValue: 'na',
      formFieldName: 'Tenor'
    })]));
  });
  
  test("triggerAdobeEvent pushes correct data to adobeDataLayer", () => {
    window.adobeDataLayer = []; // Reset adobeDataLayer
    const stageMock = {
      stages: {
        stages: [{
          stageInfo: {
            applicants: {
              profile_id: 'P123',
            },
          },
        }],
      },
      auth: {
        SSCode: true
      },
    };

    store.getState.mockReturnValue(stageMock);
    trackEvents.triggerAdobeEvent('formSubmit', 'Submit');

    expect(window.adobeDataLayer.length).toBe(1);
    expect(window.adobeDataLayer[0].event).toBe('formSubmit');
    expect(window.adobeDataLayer[0].form.refNum).toBe('app_001'); // Check against your dynamic application reference number
  });

  test("atViewStart function pushes correct view event to adobeDataLayer", () => {
    window.adobeDataLayer = []; // Reset adobeDataLayer
    const stageMock = {
      stages: {
        stages: [{
          stageInfo: {
            products: [
              { product_category: 'SA', name: 'Product 1', product_type: 'Type 1' }
            ]
          },
        }],
      },
    };

    store.getState.mockReturnValue(stageMock);
    trackEvents.atViewStart();

    expect(window.adobeDataLayer.length).toBe(1);
    expect(window.adobeDataLayer[0].event).toBe('at-view-start');
  });

  // Add more tests as needed...
});
