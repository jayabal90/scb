// actions.test.ts
import { store } from "../utils/store/store"; // Your store
import { dispatchError, dispatchLoader, getLovData } from "./your-actions-file"; // Import your actions
import { errorAction } from "../utils/store/error-slice";
import { loaderAction } from "../utils/store/loader-slice";
import axios from "axios";
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

// Mock the axios module
jest.mock("axios");

// Create a mock store
const middlewares = [thunk];
const mockStore = configureStore(middlewares);

describe("Redux Actions", () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({});
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("dispatchError", () => {
    it("should dispatch errorAction when error has response", () => {
      const errorResponse = {
        response: {
          status: 404,
          statusText: "Not Found",
        },
      };
      const expectedActions = [
        loaderAction.getState({ isFetching: false }),
        errorAction.getError({
          statusCode: 404,
          statusText: "Not Found",
        }),
      ];

      store.dispatch(dispatchError(errorResponse));

      const actions = store.getActions();
      expect(actions).toEqual(expectedActions);
    });

    it("should dispatch default errorAction when no response", () => {
      const errorResponse = {};
      const expectedActions = [
        loaderAction.getState({ isFetching: false }),
        errorAction.getError({
          statusCode: "error",
          statusText: "no response",
        }),
      ];

      store.dispatch(dispatchError(errorResponse));

      const actions = store.getActions();
      expect(actions).toEqual(expectedActions);
    });
  });

  describe("dispatchLoader", () => {
    it("should dispatch loader state", () => {
      const expectedActions = [
        loaderAction.getState({ isFetching: true }),
      ];

      store.dispatch(dispatchLoader(true));

      const actions = store.getActions();
      expect(actions).toEqual(expectedActions);
    });
  });

  describe("getLovData", () => {
    it("should fetch LOV data and dispatch lovAction", async () => {
      const mockResponse = {
        data: [
          { CODE_DESC: "Description 1", CODE_VALUE: "Value 1" },
          { CODE_DESC: "Description 2", CODE_VALUE: "Value 2" },
        ],
      };
      (axios.get as jest.Mock).mockResolvedValueOnce(mockResponse);

      const field = "someField";
      await store.dispatch(getLovData(field));

      const actions = store.getActions();
      expect(actions).toContainEqual(
        expect.objectContaining({
          type: "LOV_ACTION_TYPE", // Replace with the actual action type
          payload: {
            label: field,
            value: mockResponse.data,
          },
        })
      );
    });

    it("should dispatch errors from getLovData", async () => {
      (axios.get as jest.Mock).mockRejectedValueOnce(new Error("Network error"));

      await store.dispatch(getLovData("someField"));

      const actions = store.getActions();
      expect(actions).toContainEqual(
        expect.objectContaining({
          type: "ERROR_ACTION_TYPE", // Replace with the actual error action type
        })
      );
    });
  });
});
