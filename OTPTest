import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { useDispatch, useSelector } from 'react-redux';
import OTPModel from './OTPModel'; // Adjust the import path as necessary
import * as preApprovalServices from '../../../modules/preApproval/services/preApprovalServices';

jest.mock('react-redux', () => ({
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

jest.mock('../../../modules/preApproval/services/preApprovalServices', () => ({
  getRandomChallenge: jest.fn(),
  getGenerateOtp: jest.fn(),
  getVerifyOtp: jest.fn(),
  getEnquiryData: jest.fn(),
  getDedupeData: jest.fn(),
}));

describe('OTPModel', () => {
  const mockDispatch = jest.fn();
  
  beforeEach(() => {
    useDispatch.mockReturnValue(mockDispatch);
    
    // Mocking the state slice you need from the redux store
    useSelector.mockImplementation((callback) => {
      return callback({
        stages: {
          stages: [],
          userInput: {
            applicants: [{ mobile_number: '1234567890' }]
          }
        },
        preApproval: {
          formConfigmetaData: {
            application: { channel_reference: 'CHANNEL_REF_123' },
            products: [{ /* product data */ }]
          }
        },
        model: {
          toggleModel: false
        }
      });
    });
  });
  
  it('should render OTPModel correctly', async () => {
    render(<OTPModel />);
    
    expect(screen.getByText(/Enter the 6-digit code sent to/i)).toBeInTheDocument();
    
    // Check for OTP input fields
    for (let i = 1; i <= 6; i++) {
      expect(screen.getByLabelText(`otp${i}`)).toBeInTheDocument();
    }
  });
  
  it('should generate OTP on mount', async () => {
    preApprovalServices.getRandomChallenge.mockResolvedValueOnce({
      status: 200,
      data: { data: { attributes: {} } }
    });
    
    preApprovalServices.getGenerateOtp.mockResolvedValueOnce({
      data: { data: { attributes: { 'otp-prefix': 'FBrv - ' } } },
    });

    render(<OTPModel />);
    
    await waitFor(() => expect(preApprovalServices.getRandomChallenge).toHaveBeenCalled());
    expect(preApprovalServices.getGenerateOtp).toHaveBeenCalled();
  });

  it('should handle OTP input correctly', async () => {
    render(<OTPModel />);
    
    const otpInputs = screen.getAllByRole('textbox'); // Assuming your inputs are of type `input`
    
    // Simulating user input for OTP
    otpInputs[0].value = '1';
    fireEvent.change(otpInputs[0]);
    
    expect(otpInputs[0].value).toBe('1');

    fireEvent.change(otpInputs[1], { target: { value: '2' } });
    expect(otpInputs[1].value).toBe('2');
    
    // Check if the next field was focused if the prev field was filled
    expect(otpInputs[2]).toHaveFocus();
  });

  it('should show error when OTP is invalid', async () => {
    // Set up to simulate an invalid OTP response
    preApprovalServices.getVerifyOtp.mockResolvedValueOnce({
      status: 400
    });

    render(<OTPModel />);

    // Simulate filling OTP & submitting
    // Implementation would vary based on how you trigger OTP validation.

    // Expect to see the error message
    expect(screen.getByText(/incorrect otp/i)).toBeInTheDocument();
  });
  
  it('should allow user to request a new OTP', async () => {
    render(<OTPModel />);

    // Simulate clicking on resend OTP
    const resendOtpButton = screen.getByText(/resend otp/i); // Update selector based on your implementation
    fireEvent.click(resendOtpButton);
    
    await waitFor(() => expect(preApprovalServices.getGenerateOtp).toHaveBeenCalled());
  });
});
