import React from 'react';
import { shallow } from 'enzyme';
import { useDispatch, useSelector } from 'react-redux';
import OTPModel from './OTPModel'; // Adjust import path as necessary
import { preApprovalAction } from '../../../modules/preApproval/store/preApproval-slice';
import modelInfo from '../../../assets/_json/model.json';

jest.mock('react-redux', () => ({
  useSelector: jest.fn(),
  useDispatch: jest.fn(),
}));

describe('<OTPModel />', () => {
  let dispatch;
  let wrapper;

  beforeEach(() => {
    // Create a mock dispatch function
    dispatch = jest.fn();
    useDispatch.mockReturnValue(dispatch);

    // Set up the mock return values for useSelector
    useSelector.mockImplementation((callback) => {
      const stateMock = {
        stages: {
          stages: [{ /* your mock stage data here */ }],
          userInput: {
            applicants: [{ mobile_number: '1234567890' }],
          },
        },
        model: {
          toggleModel: false,
        },
        preApproval: {
          formConfigmetaData: {
            application: { channel_reference: 'some_reference' },
            products: [{}],
          },
        },
      };
      return callback(stateMock);
    });

    // Use shallow rendering for component
    wrapper = shallow(<OTPModel />);
  });

  afterEach(() => {
    jest.clearAllMocks(); // Reset mocks after each test
  });

  it('should render without crashing', () => {
    expect(wrapper.exists()).toBe(true);
  });

  it('should call generateOtp on mount', () => {
    const instance = wrapper.instance();
    const spy = jest.spyOn(instance, 'generateOtp');
    instance.componentDidMount();
    expect(spy).toHaveBeenCalled();
  });

  it('should show expired OTP message when seconds are 0', () => {
    wrapper.setState({ seconds: 0 });
    expect(wrapper.find('.expired-color').exists()).toBeTruthy();
  });

  it('should call dispatch on requestNewOtp', () => {
    wrapper.instance().didntReceiveOtp(); // Call function that dispatches new OTP
    expect(dispatch).toHaveBeenCalled();
  });

  it('should update OTP value on input change', () => {
    const otpInput = wrapper.find('input#otp1'); // Assuming the input has id `otp1`
    otpInput.simulate('change', { target: { value: '1' } });
    expect(wrapper.state('otpVal')).toContain('1');
  });

  // Add more tests for other functionalities as needed

});
