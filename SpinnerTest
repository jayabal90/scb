// service.test.ts
import trackEvents from '../path/to/service';
import { store } from "../utils/store/store";
import { getUrl } from "../utils/common/change.utils";

jest.mock("../utils/store/store"); // Mock store to control its behavior
jest.mock("../utils/common/change.utils"); // Mock getUrl

describe('Service Class Tests', () => {
    const mockStage = {
        stages: {
            stages: [
                {
                    stageId: 'someStageId',
                    stageInfo: {
                        applicants: {
                            profile_id: '1234',
                            userInput: {
                                applicants: {},
                            },
                        },
                        fieldMetaData: {
                            country: 'CA',
                        },
                        products: [
                            {
                                name: 'Product A',
                                product_type: 'typeA',
                                product_category: 'SA',
                            },
                        ],
                    },
                },
            ]
        },
    };

    beforeEach(() => {
        // Reset the store's state or any other mocks before each test
        jest.clearAllMocks();
        store.getState.mockReturnValue(mockStage);
        getUrl.getChannelRefNo.mockReturnValue({
            channelRefNo: 'channel123',
            applicationRefNo: 'app123',
        });
    });

    test('getFormFieldValue returns correct value for Yes LOV', () => {
        const labelName = 'Some Label';
        const stage = { ...mockStage }; // Adjust as necessary
        const lov = 'Yes';
        
        const mockValue = 'someValue';
        stage.stages.stages[0].stageInfo.userInput = {
            applicants: {
                [labelName + '_a_1']: mockValue,
            },
        };
        const result = trackEvents.getFormFieldValue(labelName, stage, lov);

        expect(result).toBe('expected LOV description'); // Adjust expected value as necessary
    });

    test('getFormFields returns the correct form field objects', () => {
        const stageId = 'someStageId';
        const logicalNames = ['Some Label'];
        
        const result = trackEvents.getFormFields(stageId, mockStage, logicalNames);
        
        expect(result).toHaveLength(1); // Should return at least one field
        expect(result[0]).toHaveProperty('formFieldName');
        expect(result[0]).toHaveProperty('formFieldValue');
    });

    test('triggerAdobeEvent pushes the right data to window.adobeDataLayer', () => {
        window.adobeDataLayer = [];

        const stageId = 'someStageId';
        const eventName = 'formStart';
        const stepName = 'formStep1';

        trackEvents.triggerAdobeEvent(eventName, 'Continue', null, null);

        expect(window.adobeDataLayer).toHaveLength(1);
        expect(window.adobeDataLayer[0]).toHaveProperty('event', eventName);
        expect(window.adobeDataLayer[0].form).toHaveProperty('refNum', 'app123');
    });

    test('getProductInfo returns correct product info', () => {
        const result = trackEvents.getProductInfo(mockStage);
        
        expect(result).toHaveLength(2); // Should return info and form info
        expect(result[0].productInfo).toEqual({
            productName: 'Product A',
            productID: 'typeA',
            productCategory: 'SA',
            productSubCategory: 'na',
        });
        expect(result[1].formInfo).toHaveProperty('formName');
    });

    test('getAdobeDataLayer returns structured data object', () => {
        const eventName = 'pageView';
        const stepName = 'step1';

        const result = trackEvents.getAdobeDataLayer(eventName, mockStage, stepName);

        expect(result).toHaveProperty('event', eventName);
        expect(result.page.pageInfo).toHaveProperty('pageType', 'form');
        expect(result.user.userInfo).toHaveProperty('userID', 'na');
    });

    // More tests to be added as needed...
});
