import React from "react";
import { shallow, mount } from "enzyme";
import configureStore from "redux-mock-store";
import { Provider } from "react-redux";
import { useDispatch, useSelector } from "react-redux";
import MultiSelectionBox from "./MultiSelectionBox"; // Adjust the import path
import { ValueUpdateAction } from "../../../utils/store/value-update-slice";
import { lovDescAction } from "../../../utils/store/lov-desc-slice";

jest.mock("react-redux", () => ({
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

const mockDispatch = jest.fn();
const mockStore = configureStore([]);

describe("MultiSelectionBox Component", () => {
  let store;
  let mockProps;

  beforeEach(() => {
    store = mockStore({
      lov: { lov: [] },
      fielderror: { error: {} },
      stages: { stages: [], userInput: { applicants: [{}] } },
    });

    useDispatch.mockReturnValue(mockDispatch);
    useSelector.mockImplementation((callback) => callback(store.getState()));

    mockProps = {
      data: {
        logical_field_name: "example_field",
        rwb_label_name: "Example Field",
        max_selects: "3",
        mandatory: "Yes",
      },
      handleCallback: jest.fn(),
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should render the MultiSelectionBox component correctly", () => {
    const wrapper = mount(
      <Provider store={store}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );

    expect(wrapper.find(".multi-select").exists()).toBe(true);
    expect(wrapper.find("label").text()).toBe("Example Field");
  });

  it("should handle dropdown open and close actions", () => {
    const wrapper = mount(
      <Provider store={store}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );

    wrapper.find(".multi-select__field").simulate("click");
    expect(wrapper.find(".multi-select__popup").exists()).toBe(true);

    wrapper.find(".close").simulate("click");
    expect(wrapper.find(".multi-select__popup").exists()).toBe(false);
  });

  it("should dispatch actions when a value is selected", () => {
    const mockLovValue = {
      CODE_DESC: "Option 1",
      CODE_VALUE: "opt1",
    };

    const wrapper = shallow(<MultiSelectionBox {...mockProps} />);
    wrapper.find("input[type='checkbox']").simulate("change", {
      target: { checked: true },
    });

    expect(mockDispatch).toHaveBeenCalledWith(
      lovDescAction.addLovData({
        fieldData: {
          fieldName: "example_field",
          code_desc: "Option 1",
          code_value: "opt1",
        },
      })
    );
  });

  it("should handle no results during search", () => {
    const wrapper = mount(
      <Provider store={store}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );

    wrapper.find("input[name='search']").simulate("change", {
      target: { value: "nonexistent" },
    });

    expect(wrapper.find(".multi-select__noResult").exists()).toBe(true);
  });

  it("should show error messages when mandatory field is empty", () => {
    const wrapper = mount(
      <Provider store={store}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );

    wrapper.find(".multi-select__btn--disabled").simulate("click");
    expect(wrapper.find(".error-msg").text()).toContain(
      "Example Field"
    );
  });

  it("should handle continue button action correctly", () => {
    const wrapper = shallow(<MultiSelectionBox {...mockProps} />);
    const continueBtn = wrapper.find(".multi-select__btn span");

    continueBtn.simulate("click");
    expect(mockDispatch).toHaveBeenCalled();
  });
});
